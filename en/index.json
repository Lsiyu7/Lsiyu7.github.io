[{"content":"Xserve调试方法 调试前置步骤 1、获取源码 apt source xserver-xorg-core\n2、安装相关库依赖 sudo apt build-dep xserver-xorg-core\n编译步骤 方法一 1 2 3 DEB_CFLAGS_SET=\u0026#34;-ggdb3 -O0 -fdebug-prefix-map=/home/{pwd}/xserver-xorg=. -fstack-protector-strong -Wformat -Werror=format-security\u0026#34; DEB_CXXFLAGS_SET=\u0026#34;-ggdb3 -O0 -fdebug-prefix-map=/home/{pwd}/xserver-xorg=. -fstack-protector-strong -Wformat -Werror=format-security\u0026#34; dpkg-buildpackage -uc -b 后续需要改动时\n1 2 3 DEB_CFLAGS_SET=\u0026#34;-ggdb3 -O0 -fdebug-prefix-map=/home/siyu/xserver-xorg=. -fstack-protector-strong -Wformat -Werror=format-security\u0026#34; DEB_CXXFLAGS_SET=\u0026#34;-ggdb3 -O0 -fdebug-prefix-map=/home/siyu/xserver-xorg=. -fstack-protector-strong -Wformat -Werror=format-security\u0026#34; dpkg-buildpackage -uc -nc -b 命令含义：\n-ggdb3: 指定生成调试信息的级别为GDB调试器的级别3。这将为调试提供更详细和丰富的信息。\n-O0: 禁用优化。编译器将不会进行任何优化，这有助于在调试过程中更容易理解源代码。\n-fdebug-prefix-map=/home/siyu/xserver-xorg=.: 指定调试信息中源代码路径的映射关系。将/home/siyu/xserver-xorg的路径映射为.，即当前目录。\n-fstack-protector-strong: 启用堆栈保护。编译器将插入额外的代码来保护函数的局部变量和返回地址，以防止缓冲区溢出攻击。\n-Wformat: 启用格式化字符串检查警告。编译器将检查printf和scanf等函数的格式字符串是否与参数匹配。\n-Werror=format-security: 将格式化字符串检查警告视为错误。如果编译过程中出现格式化字符串不匹配的警告。\ndpkg-buildpackage：这是Debian中用于构建软件包的常用工具。它会根据软件包的源代码和Debian规则文件进行构建，并生成二进制软件包（包括.deb文件）。\n-uc：在构建过程中跳过对软件包源代码的签名验证。这通常用于开发和测试目的，以避免在每次构建时进行源代码签名。\n-b：仅构建二进制软件包，而不构建源代码软件包。这可以加快构建过程，如果只需要生成可执行文件和相关的二进制文件，而不关心源代码软件包。\n-nc：不清理为改动文件。\n方法二 ./autogen.sh\n修改makefile文件\n将CFLAGS和CCASFLAGS 选项修改成\n1 2 CCASFLAGS = -g -O0 CFLAGS = -g -O0 执行make -j8\n调试步骤 find -name \u0026quot;Xorg\u0026quot; 找到编译文件\n首先备份系统本身Xorg：\nsudo mv /usr/lib/xorg/Xorg /usr/lib/xorg/Xorg.org\n将自己编译的文件移动到该目录下： sudo cp /home/..../Xorg /usr/lib/xorg\n为保证GDB可以显示源文件，gdb调试需要在编译文件夹下进行调试。\nps -aux | grep X 找到正在运行的xorg pid\nsudo gdb attach {pid} 调试正在运行的程序\n！！！ 若要调试/usr/lib/xorg/modules下的库文件 也是找到备份替换。\n寻找包依赖\n1 2 3 #两种方法 apt-cache search \u0026lt;\u0026gt; dpkg -S \u0026lt;\u0026gt; 命令总结 dpkg-buildpackage命令详解：\n选项 描述 -uc 跳过对软件包源代码的签名验证。 -b 仅构建二进制软件包，而不构建源代码软件包。 -j 指定并行构建的作业数。 -S 仅构建源代码软件包，而不构建二进制软件包。 -sa 在生成源代码软件包时，将原始源代码文件包含在内。 -sd 在生成源代码软件包时，不包含原始源代码文件。 -tc= 指定构建过程中的临时目录。 -rfakeroot 在构建过程中使用fakeroot工具模拟root权限。 -A 仅构建所有架构无关的软件包。 -B 仅构建所有架构相关的软件包。 -d 忽略构建软件包时的依赖关系。 -i 忽略构建软件包时的建议关系。 -I 忽略构建软件包时的建议关系和所有其他关系。 -tc= 使用指定的目录作为临时构建目录。 -S -si -sa 生成并签名源代码软件包，包括原始源代码文件。 \u0026ndash;no-pre-clean 在构建之前不执行预清理操作。 \u0026ndash;no-preparation 跳过构建准备阶段。 \u0026ndash;no-act 仅显示将执行的操作，而不实际执行。 \u0026ndash;build=any 构建所有支持的架构。 \u0026ndash;preserve-env 保留当前环境变量，不重置为默认值。 \u0026ndash;exclude= 在构建过程中排除指定的软件包。 \u0026ndash;force-sign 强制对软件包进行签名。 \u0026ndash;no-sign 不对软件包进行签名。 \u0026ndash;unsigned-changes 允许使用未签名的.changes文件。 \u0026ndash;source-option= 传递额外的选项给dpkg-source命令。 错误勘察 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 apt-get install build-essential apt-get install libepoxy-dev $ ./autogen.sh ./autogen.sh: 9: ./autogen.sh: autoreconf: not found # apt --fix-broken install # apt-get install dh-autoreconf $ ./autogen.sh configure.ac:38: error: must install xorg-macros 1.14 or later before running autoconf/autogen # apt-get install xutils-dev $ ./autogen.sh configure.ac:52: error: must install font-util 1.1 or later before running autoconf/autogen # apt-get install xfonts-utils -y $ ./autogen.sh configure: error: Package requirements (glproto \u0026gt;= 1.4.17 gl \u0026gt;= 9.2.0) were not met: # apt-get install x11proto-gl-dev $ ./autogen.sh configure: error: Package requirements (x11) were not met: # apt-get install libx11-dev $ ./autogen.sh configure: error: Package requirements (glproto \u0026gt;= 1.4.17 gl \u0026gt;= 9.2.0) were not met: No package \u0026#39;gl\u0026#39; found # apt-get install mesa-common-dev # apt-get install libgl1-mesa-dev 失败 //这里不要机械，根据环境不同，酌情成功安装 libgl1-mesa-dev x11proto-gl-dev 即可 # apt-get install aptitude # aptitude install libgl1-mesa-dev $ ./autogen.sh checking for SHA1 implementation... configure: error: No suitable SHA1 implementation found # apt-get install libssl-dev $ ./autogen.sh configure: error: Package requirements (fixesproto \u0026gt;= 5.0 damageproto \u0026gt;= 1.1 xcmiscproto \u0026gt;= 1.2.0 xtrans \u0026gt;= 1.3.5 bigreqsproto \u0026gt;= 1.1.0 xproto \u0026gt;= 7.0.31 randrproto \u0026gt;= 1.6.0 renderproto \u0026gt;= 0.11 xextproto \u0026gt;= 7.2.99.901 inputproto \u0026gt;= 2.3 kbproto \u0026gt;= 1.0.3 fontsproto \u0026gt;= 2.1.3 pixman-1 \u0026gt;= 0.27.2 videoproto compositeproto \u0026gt;= 0.4 recordproto \u0026gt;= 1.13.99.1 scrnsaverproto \u0026gt;= 1.1 resourceproto \u0026gt;= 1.2.0 xf86driproto \u0026gt;= 2.1.0 glproto \u0026gt;= 1.4.17 dri \u0026gt;= 7.8.0 presentproto \u0026gt;= 1.1 xineramaproto xkbfile pixman-1 \u0026gt;= 0.27.2 xfont2 \u0026gt;= 2.0.0 xau xshmfence \u0026gt;= 1.1 xdmcp) were not met: No package \u0026#39;xcmiscproto\u0026#39; found No package \u0026#39;bigreqsproto\u0026#39; found No package \u0026#39;randrproto\u0026#39; found No package \u0026#39;renderproto\u0026#39; found No package \u0026#39;fontsproto\u0026#39; found No package \u0026#39;videoproto\u0026#39; found No package \u0026#39;compositeproto\u0026#39; found No package \u0026#39;recordproto\u0026#39; found No package \u0026#39;scrnsaverproto\u0026#39; found No package \u0026#39;resourceproto\u0026#39; found No package \u0026#39;xf86driproto\u0026#39; found No package \u0026#39;presentproto\u0026#39; found No package \u0026#39;xineramaproto\u0026#39; found No package \u0026#39;xkbfile\u0026#39; found No package \u0026#39;xfont2\u0026#39; found # apt-get install x11proto-xcmisc-dev # apt-get install x11proto-randr-dev # apt-get install x11proto-render-dev # apt-get install x11proto-video-dev # apt-get install x11proto-composite-dev # apt-get install x11proto-record-dev # apt-get install x11proto-scrnsaver-dev # apt-get install x11proto-resource-dev # apt-get install x11proto-xf86dri-dev # apt-get install x11proto-present-dev # apt-get install x11proto-xinerama-dev # apt-get install libxkbfile-dev # apt-get install libxfont-dev # apt-get install x11proto-bigreqs-dev $ ./autogen.sh checking for XSERVERCFLAGS... no configure: error: Package requirements (fixesproto \u0026gt;= 5.0 damageproto \u0026gt;= 1.1 xcmiscproto \u0026gt;= 1.2.0 xtrans \u0026gt;= 1.3.5 bigreqsproto \u0026gt;= 1.1.0 xproto \u0026gt;= 7.0.31 randrproto \u0026gt;= 1.6.0 renderproto \u0026gt;= 0.11 xextproto \u0026gt;= 7.2.99.901 inputproto \u0026gt;= 2.3 kbproto \u0026gt;= 1.0.3 fontsproto \u0026gt;= 2.1.3 pixman-1 \u0026gt;= 0.27.2 videoproto compositeproto \u0026gt;= 0.4 recordproto \u0026gt;= 1.13.99.1 scrnsaverproto \u0026gt;= 1.1 resourceproto \u0026gt;= 1.2.0 xf86driproto \u0026gt;= 2.1.0 glproto \u0026gt;= 1.4.17 dri \u0026gt;= 7.8.0 presentproto \u0026gt;= 1.1 xineramaproto xkbfile pixman-1 \u0026gt;= 0.27.2 xfont2 \u0026gt;= 2.0.0 xau xshmfence \u0026gt;= 1.1 xdmcp) were not met: No package \u0026#39;bigreqsproto\u0026#39; found Requested \u0026#39;randrproto \u0026gt;= 1.6.0\u0026#39; but version of RandrProto is 1.5.0 No package \u0026#39;fontsproto\u0026#39; found No package \u0026#39;xfont2\u0026#39; found # apt-get install libxfont2 # apt-get install libxfont-dev //环境有问题 # aptitude install libxfont-dev # apt-get install x11proto-bigreqs-dev # apt-get install libcurl4-openssl-dev # apt-get install libpciaccess-dev $ ./autogen.sh 正常的，这会已经差不多ok了，之前编译1.19.2同样步骤已经结束了 Requested \u0026#39;randrproto \u0026gt;= 1.6.0\u0026#39; but version of RandrProto is 1.5.0 $ ./autogen.sh ","permalink":"https://Lsiyu7.github.io/en/posts/tech/xserve%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/","summary":"Xserve调试方法 调试前置步骤 1、获取源码 apt source xserver-xorg-core 2、安装相关库依赖 sudo apt build-dep xserver-xorg-core 编译步骤 方法一 1 2 3 DEB_CFLAGS_SET=\u0026#34;-ggdb3 -O0 -fdebug-prefix-map=/home/{pwd}/xserver-xorg=. -fstack-protector-strong -Wformat -Werror=format-security\u0026#34; DEB_CXXFLAGS_SET=\u0026#34;-ggdb3 -O0 -fdebug-prefix-map=/home/{pwd}/xserver-xorg=. -fstack-protector-strong -Wformat -Werror=format-security\u0026#34; dpkg-buildpackage -uc -b 后续需要改动时","title":"Xserve调试方法"},{"content":"网络字节序与地址变换 不同的 CPU 中，4 字节整数值1在内存空间保存方式是不同的。\n有些 CPU 这样保存：\n1 00000000 00000000 00000000 00000001 有些 CPU 这样保存：\n1 00000001 00000000 00000000 00000000 两种一种是顺序保存，一种是倒序保存 。\n字节序（Order）与网络字节序 CPU 保存数据的方式有两种，这意味着 CPU 解析数据的方式也有 2 种：\n大端序（Big Endian）：高位字节存放到低位地址 小端序（Little Endian）：高位字节存放到高位地址 两台字节序不同的计算机在数据传递的过程中可能出现的问题：\n因为这种原因，所以在通过网络传输数据时必须约定统一的方式，这种约定被称为网络字节序，非常简单，统一为大端序。即，先把数据数组转化成大端序格式再进行网络传输。\n字节序转换 帮助转换字节序的函数：\n1 2 3 4 unsigned short htons(unsigned short); unsigned short ntohs(unsigned short); unsigned long htonl(unsigned long); unsigned long ntohl(unsigned long); 通过函数名称掌握其功能，只需要了解：\nhtons 的 h 代表主机（host）字节序。 little endian htons 的 n 代表网络（network）字节序。 big endian s 代表 short l 代表 long 下面的代码是示例，说明以上函数调用过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main(int argc, char *argv[]) { unsigned short host_port = 0x1234; unsigned short net_port; unsigned long host_addr = 0x12345678; unsigned long net_addr; net_port = htons(host_port); //转换为网络字节序 net_addr = htonl(host_addr); printf(\u0026#34;Host ordered port: %#x \\n\u0026#34;, host_port); printf(\u0026#34;Network ordered port: %#x \\n\u0026#34;, net_port); printf(\u0026#34;Host ordered address: %#lx \\n\u0026#34;, host_addr); printf(\u0026#34;Network ordered address: %#lx \\n\u0026#34;, net_addr); return 0; } 编译运行：\n结果：\n1 2 3 4 Host ordered port: 0x1234 Network ordered port: 0x3412 Host ordered address: 0x12345678 Network ordered address: 0x78563412 这是在小端 CPU 的运行结果。大部分人会得到相同的结果，因为 Intel 和 AMD 的 CPU 都是小端序为标准。\n","permalink":"https://Lsiyu7.github.io/en/posts/tech/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%BA%8F%E8%BD%AC%E6%8D%A2/","summary":"网络字节序与地址变换 不同的 CPU 中，4 字节整数值1在内存空间保存方式是不同的。 有些 CPU 这样保存： 1 00000000 00000000 00000000 00000001 有些 CPU 这样保存： 1 00000001 00000000 00000000 00000000 两种一种是顺序","title":"大端小端序转换"},{"content":"git 工作流 git 三个模块 ：GitHub local desk git clone \u0026lt;master\u0026gt;\ngit checkout -b local \u0026lt;my_filename\u0026gt; //checkout 切换分支 ，-b切换到一个不存在的分支，并创建 将修改后的文件告诉git git diff //比较两个代码的区别\ngit add \u0026lt;changed_filename\u0026gt; //只是加入“暂存区” git commit -m \u0026quot;XXX update\u0026quot; //local.git 新增一个commit,-m 注释内容 XXX更新\n更新github 本地更新完后，github 上也有更新 需要同步desk 与 github\ngit checkout \u0026lt;master\u0026gt; //切换到主分支\ngit pull origin \u0026lt;master\u0026gt; //将远端github update 更新到 local\ngit checkout \u0026lt;change_filename\u0026gt; //回到自己修改分支\ngit rebase \u0026lt;master\u0026gt; //将\u0026lt;change_filename\u0026gt; 修改放一边 在最新的基础上修改数据指针 合并修改\ngit rebase -i HEAD~3 当前开始找最近的三条记录开始合并\ngit push origin \u0026lt;my_filename\u0026gt;\nsquash and merge\ngit 操作 工作区\u0026raquo;\u0026raquo;暂存区\u0026raquo;\u0026raquo;仓库 git add把文件从工作区\u0026raquo;\u0026raquo;暂存区，git commit把文件从暂存区\u0026raquo;\u0026raquo;仓库，\ngit diff查看工作区和暂存区差异\ngit diff --cached 查看暂存区和仓库差异\ngit diff HEAD 查看工作区和仓库的差异\ngit add 的反向命令git checkout --[PATH]\u0026lt;filename\u0026gt; ，撤销工作区修改，即把暂存区最新版本转移到工作区\ngit commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区\n文件更改必须加入缓存区\ngit reset --hard HEAD^//回退上一个版本 --hard 参数指硬回退 直接将仓库回退到工作区\ngit reflog //查看操作版本\ngit merge \u0026lt;branch\u0026gt; //将分支合并到当前分支\ngit branch -d \u0026lt;branch\u0026gt; //删除分支 不能是当前分支\ngit status 查看文件\n","permalink":"https://Lsiyu7.github.io/en/posts/tech/git_base/","summary":"git 工作流 git 三个模块 ：GitHub local desk git clone \u0026lt;master\u0026gt; git checkout -b local \u0026lt;my_filename\u0026gt; //checkout 切换分支 ，-b切换到一个不存在的分支，并创建 将修改后的文件告诉git git diff //比较两个代","title":"Git_base"},{"content":"基础语法 尽量保证每一个文件夹有个CMakeLists.txt [[CMake Practice.pdf]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #最小支持版本 cmake_minimum_required(VERSION 3.0) #工程名称 project(SWAP) ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR} #包含头文件 当前文件绝对路径 include_directories(${CMAKE_SOURCE_DIR}include) #set 设置文件 set(SRC hello.cpp main.cpp) #修改二进制输出路径 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) #修改库文件生成路径 set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) #生成可执行文件 add_executable(main_cmake main.cpp src/swap.cpp) # 指定源文件文件夹 生成得目标文件夹 以及需要排除得文件夹 add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) #添加特定库文件搜索路径 link_directories() #生成库文件 add_library() #编译添加参数 add_compile_options(-Wall -std=c11++ -O2) #添加链接共享库 target_link_libraries() #临时将源代码文件放进一个变量里 aux_source_directory(. SRC) add_executable(main ${SRC}) #log message message() cmake 变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ##如果是 in source 编译,指得就是工程顶层目录,如果是 out-of-source 编译,指的是工程编译发生的目录 （build） CMAKE_BINARY_DIR PROJECT_BINARY_DIR ##顶层工程文件目录 CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR ##指的是当前处理的 CMakeLists.txt 所在的路径, CMAKE_CURRENT_SOURCE_DIR ##如果是 in-source 编译,它跟 CMAKE_CURRENT_SOURCE_DIR 一致,如果是 out-of-source 编译,他指的是 target 编译目录。 ##使用我们上面提到的 ADD_SUBDIRECTORY(src bin)可以更改这个变量的值 CMAKE_CURRENT_BINARY_DIR ##输出调用这个变量的 CMakeLists.txt 的完整路径 CMAKE_CURRENT_LIST_FILE ## ","permalink":"https://Lsiyu7.github.io/en/posts/tech/cmake/","summary":"基础语法 尽量保证每一个文件夹有个CMakeLists.txt [[CMake Practice.pdf]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38","title":"Cmake"},{"content":"gcc/g++常用编译选项 选项 作用 -c 生成可目标文件，但不进行链接 -o 指定生成文件的文件名 -g 在目标文件中添加调试信息，便于gdb调试或objdump反汇编 -Wall 显示所有的警告信息(建议使用) -Werror 视警告为错误，出现警告即放弃编译 -w 不显示任何警告信息(不建议使用) -v 显示编译步骤 -On (n=0,1,2,3) 设置编译器优化等级，O0为不优化，O3为最高等级优化，O1为默认优化等级 -L 指定库文件的搜索目录 -l (小写的L)链接某一库 -I (大写的i)指定头文件路径 -D 定义宏，例如-DAAA=1,-DBBBB -U 取消宏定义，例如-UAAA gdb常用调试命命令 我们的可执行文件要能够被gdb调试，必须在编译时加上调试信息，也即是加上-g选项.\n1\n$ gcc -g example.c -o example\n如上我们生成了一个带有调试信息的可执行文件example,要调试example可以执行下列命令:\n1\n$ gdb example\n这样我们就进入了gdb的调试命令行，如下所示:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nGNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git\nCopyright (C) 2018 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n\u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;.\nFind the GDB manual and other documentation resources online at:\n\u0026lt;http://www.gnu.org/software/gdb/documentation/\u0026gt;.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from example...done.\n(gdb)\n如上可以看到命令行提示符为(gdb),接着我们就可以在这个gdb的命令行提示符上面输入各种gdb的调试命令了(补充:这里也可以在shell中输入gdb,然后回车，这样直接进入到gdb的调试命令行，之后可以通过file example命令来载入待调试的可执行程序)。\n下面我们就以如下的程序为例，详细的看下，在gdb的调试命令行中我们都有那些命令可用:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n#include \u0026lt;stdio.h\u0026gt;\nlong func(int a){\nlong sum = 0;\nfor(int j=1;j\u0026lt;=a;j++){\nsum += j;\n}\nreturn sum;\n}\nint main(void){\nint a =100;\nlong sum = func(a);\nprintf(\"%ld\",sum);\nreturn 0;\n}\n查看源码 载入待调试的可执行文件之后，在gdb的命令行中输入list或者其简写l可以查看到程序的源码以及行号，如下:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n(gdb) l\n1#include \u0026lt;stdio.h\u0026gt;\n2\n3long func(int a){\n4 long sum = 0;\n5 for(int j=1;j\u0026lt;=a;j++){\n6 sum += j;\n7 }\n8 return sum;\n9}\n10\n(gdb) 11int main(void){\n12 int a =100;\n13 long sum = func(a);\n14 printf(\"%ld\",sum);\n15 return 0;\n16}\n(gdb) Line number 17 out of range; example.c has 16 lines.\n(gdb)\n如上输入l之后，默认会显示10行源代码，按回车之后会显示接下来的10行,直到文件的末尾。\n添加断点 在gdb下添加断点使用命令break或简写 b，有下面几个常见用法（这里统一用 b:\n1\n2\n3\n4\nb 函数名\nb 行号\nb 文件名:行号\nb 行号 if条件\n比如我们在 main函数和func函数上各添加一个断点：\n1\n2\n3\n4\n(gdb) b main\nBreakpoint 1 at 0x685: file example.c, line 12.\n(gdb) break func\nBreakpoint 2 at 0x651: file example.c, line 4.\n如上我们成功加上了两个断点，在正确加上断点之后，会对应有一行输出，告诉我们断点的内存地址，断点对应的源文件名和行号。\n查看断点 在加上断点之后，我们可以通过info break命令查看断点的信息:\n1\n2\n3\n4\n(gdb) info break\nNum Type Disp Enb Address What\n1 breakpoint keep y 0x0000000000000685 in main at example.c:12\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n禁用和解禁断点 通过disable \u0026lt;break number\u0026gt;来禁用指定Num的断点，如下我们禁用1号断点:\n1\n2\n3\n4\n5\n(gdb) disable 1\n(gdb) info break\nNum Type Disp Enb Address What\n1 breakpoint keep n 0x0000000000000685 in main at example.c:12\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n如上，disable 1之后，断点1的Enb列由之前的y变成了n，说明断点1已被禁用。\n通过eable \u0026lt;break number\u0026gt;可以来解禁断点，如下我们对刚才禁用的断点1解禁:\n1\n2\n3\n4\n5\n(gdb) enable 1\n(gdb) info break\nNum Type Disp Enb Address What\n1 breakpoint keep y 0x0000000000000685 in main at example.c:12\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n如上，断点1的Enb列又变成y了，它被成功解禁。\n删除断点 我们可以用delete \u0026lt;break number\u0026gt;命令来删除掉一个断点，如下我们删除断点1:\n1\n2\n3\n4\n(gdb) delete 1\n(gdb) info break\nNum Type Disp Enb Address What\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n如上，断点1被成功删除。\n启动程序 我们可以使用run命令或者简写r来启动程序的执行:\n1\n2\n3\n4\n5\n(gdb) r\nStarting program: /home/andrew/example Breakpoint 2, func (a=100) at example.c:4\n4 long sum = 0;\n如上，程序执行到断点2的时候就停止执行了。\n查看变量的值 p \u0026lt;variable name\u0026gt;/print \u0026lt;variable name\u0026gt;可以查看某一个变量的当前值:\n1\n2\n(gdb) p sum\n$1 = 0\n如上，当前sum的值为0\n单步执行 next命令或者n可以单步执行，如下:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) p sum\n$2 = 0\n(gdb) n\n6 sum += j;\n(gdb) p sum\n$3 = 0\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) p sum\n$4 = 1\n(gdb) n\n6 sum += j;\n(gdb) p sum\n$5 = 1\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) p sum\n$6 = 3\n跳入跳出函数 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n(gdb) break 13\nBreakpoint 1 at 0x693: file example.c, line 13.\n(gdb) r\nStarting program: /home/andrew/example Breakpoint 1, main () at example.c:13\n13 long sum = func(a);\n(gdb) s\nfunc (a=100) at example.c:4\n4 long sum = 0;\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) n\n6 sum += j;\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) n\n6 sum += j;\n(gdb) finish\nRun till exit from #0 func (a=100) at example.c:6\n0x000055555555469d in main () at example.c:13\n13 long sum = func(a);\nValue returned is $1 = 5050\n(gdb) n\n14 printf(\"%ld\",sum);\n(gdb)\n如上，我在func()函数调用行加上了断点，然后r开始执行程序，之后程序在断点处停住，此时我执行step命令或其简写s来跳入func()函数内部调试，在内部依然像执行外部调试一样，如果要从函数跳出则执行finished，这时会导致函数执行完毕，并且打印出一些函数的返回信息，并且程序停在函数后的第一条语句处。\n监控变量 使用watch \u0026lt;varible name\u0026gt;命令可以实现监控变量，使用info watch命令可以查看监控的变量。同时break所拥有的enable,disable,delete等动词对于watch依然使用，且用法大同小异。这里就不再赘述。\n显示变量的值 使用display \u0026lt;varible name\u0026gt;命令可以在每一步执行之后打印变量的当前值,如下:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n(gdb) start Temporary breakpoint 1 at 0x685: file example.c, line 12.\nStarting program: /home/andrew/example Temporary breakpoint 1, main () at example.c:12\n12 int a =100, b =50;\n(gdb) display sum\n1: sum = 140737488346112\n(gdb) n\n13 long sum = func(a);\n1: sum = 140737488346112\n(gdb) 14 printf(\"%ld\",sum);\n1: sum = 5050\n(gdb) 16 long sum2 = func(b);\n1: sum = 5050\n(gdb) 17 printf(\"%ld\",sum2);\n1: sum = 5050\n(gdb) 18 return 0;\n1: sum = 5050\n(gdb)\n进入shell shell命令可以让我们从gdb命令行环境进入到shell的命令行环境，当我们在shell命令行环境中输入exit退出后，我们就又回到了之前的gdb命令行环境了。\n可视化调试 在gdb命令行环境中输入wi命令，可以让我们进入可视化调试环境，这个环境可以看到源代码，所使用的调试命令与上面讲到的一致。\n","permalink":"https://Lsiyu7.github.io/en/posts/tech/gdb/","summary":"gcc/g++常用编译选项 选项 作用 -c 生成可目标文件，但不进行链接 -o 指定生成文件的文件名 -g 在目标文件中添加调试信息，便于gdb调试或objdu","title":"Gdb"}]