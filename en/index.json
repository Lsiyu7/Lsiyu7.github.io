[{"content":"网络字节序与地址变换 不同的 CPU 中，4 字节整数值1在内存空间保存方式是不同的。\n有些 CPU 这样保存：\n1 00000000 00000000 00000000 00000001 有些 CPU 这样保存：\n1 00000001 00000000 00000000 00000000 两种一种是顺序保存，一种是倒序保存 。\n字节序（Order）与网络字节序 CPU 保存数据的方式有两种，这意味着 CPU 解析数据的方式也有 2 种：\n大端序（Big Endian）：高位字节存放到低位地址 小端序（Little Endian）：高位字节存放到高位地址 两台字节序不同的计算机在数据传递的过程中可能出现的问题：\n因为这种原因，所以在通过网络传输数据时必须约定统一的方式，这种约定被称为网络字节序，非常简单，统一为大端序。即，先把数据数组转化成大端序格式再进行网络传输。\n字节序转换 帮助转换字节序的函数：\n1 2 3 4 unsigned short htons(unsigned short); unsigned short ntohs(unsigned short); unsigned long htonl(unsigned long); unsigned long ntohl(unsigned long); 通过函数名称掌握其功能，只需要了解：\nhtons 的 h 代表主机（host）字节序。 little endian htons 的 n 代表网络（network）字节序。 big endian s 代表 short l 代表 long 下面的代码是示例，说明以上函数调用过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main(int argc, char *argv[]) { unsigned short host_port = 0x1234; unsigned short net_port; unsigned long host_addr = 0x12345678; unsigned long net_addr; net_port = htons(host_port); //转换为网络字节序 net_addr = htonl(host_addr); printf(\u0026#34;Host ordered port: %#x \\n\u0026#34;, host_port); printf(\u0026#34;Network ordered port: %#x \\n\u0026#34;, net_port); printf(\u0026#34;Host ordered address: %#lx \\n\u0026#34;, host_addr); printf(\u0026#34;Network ordered address: %#lx \\n\u0026#34;, net_addr); return 0; } 编译运行：\n结果：\n1 2 3 4 Host ordered port: 0x1234 Network ordered port: 0x3412 Host ordered address: 0x12345678 Network ordered address: 0x78563412 这是在小端 CPU 的运行结果。大部分人会得到相同的结果，因为 Intel 和 AMD 的 CPU 都是小端序为标准。\n","permalink":"https://Lsiyu7.github.io/en/posts/tech/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E5%BA%8F%E8%BD%AC%E6%8D%A2/","summary":"网络字节序与地址变换 不同的 CPU 中，4 字节整数值1在内存空间保存方式是不同的。 有些 CPU 这样保存： 1 00000000 00000000 00000000 00000001 有些 CPU 这样保存： 1 00000001 00000000 00000000 00000000 两种一种是顺序","title":"大端小端序转换"},{"content":"git 工作流 git 三个模块 ：GitHub local desk git clone \u0026lt;master\u0026gt;\ngit checkout -b local \u0026lt;my_filename\u0026gt; //checkout 切换分支 ，-b切换到一个不存在的分支，并创建 将修改后的文件告诉git git diff //比较两个代码的区别\ngit add \u0026lt;changed_filename\u0026gt; //只是加入“暂存区” git commit -m \u0026quot;XXX update\u0026quot; //local.git 新增一个commit,-m 注释内容 XXX更新\n更新github 本地更新完后，github 上也有更新 需要同步desk 与 github\ngit checkout \u0026lt;master\u0026gt; //切换到主分支\ngit pull origin \u0026lt;master\u0026gt; //将远端github update 更新到 local\ngit checkout \u0026lt;change_filename\u0026gt; //回到自己修改分支\ngit rebase \u0026lt;master\u0026gt; //将\u0026lt;change_filename\u0026gt; 修改放一边 在最新的基础上修改数据指针 合并修改\ngit rebase -i HEAD~3 当前开始找最近的三条记录开始合并\ngit push origin \u0026lt;my_filename\u0026gt;\nsquash and merge\ngit 操作 工作区\u0026raquo;\u0026raquo;暂存区\u0026raquo;\u0026raquo;仓库 git add把文件从工作区\u0026raquo;\u0026raquo;暂存区，git commit把文件从暂存区\u0026raquo;\u0026raquo;仓库，\ngit diff查看工作区和暂存区差异\ngit diff --cached 查看暂存区和仓库差异\ngit diff HEAD 查看工作区和仓库的差异\ngit add 的反向命令git checkout --[PATH]\u0026lt;filename\u0026gt; ，撤销工作区修改，即把暂存区最新版本转移到工作区\ngit commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区\n文件更改必须加入缓存区\ngit reset --hard HEAD^//回退上一个版本 --hard 参数指硬回退 直接将仓库回退到工作区\ngit reflog //查看操作版本\ngit merge \u0026lt;branch\u0026gt; //将分支合并到当前分支\ngit branch -d \u0026lt;branch\u0026gt; //删除分支 不能是当前分支\ngit status 查看文件\n","permalink":"https://Lsiyu7.github.io/en/posts/tech/git_base/","summary":"git 工作流 git 三个模块 ：GitHub local desk git clone \u0026lt;master\u0026gt; git checkout -b local \u0026lt;my_filename\u0026gt; //checkout 切换分支 ，-b切换到一个不存在的分支，并创建 将修改后的文件告诉git git diff //比较两个代","title":"Git_base"},{"content":"基础语法 尽量保证每一个文件夹有个CMakeLists.txt [[CMake Practice.pdf]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #最小支持版本 cmake_minimum_required(VERSION 3.0) #工程名称 project(SWAP) ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR} #包含头文件 当前文件绝对路径 include_directories(${CMAKE_SOURCE_DIR}include) #set 设置文件 set(SRC hello.cpp main.cpp) #修改二进制输出路径 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) #修改库文件生成路径 set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) #生成可执行文件 add_executable(main_cmake main.cpp src/swap.cpp) # 指定源文件文件夹 生成得目标文件夹 以及需要排除得文件夹 add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) #添加特定库文件搜索路径 link_directories() #生成库文件 add_library() #编译添加参数 add_compile_options(-Wall -std=c11++ -O2) #添加链接共享库 target_link_libraries() #临时将源代码文件放进一个变量里 aux_source_directory(. SRC) add_executable(main ${SRC}) #log message message() cmake 变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ##如果是 in source 编译,指得就是工程顶层目录,如果是 out-of-source 编译,指的是工程编译发生的目录 （build） CMAKE_BINARY_DIR PROJECT_BINARY_DIR ##顶层工程文件目录 CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR ##指的是当前处理的 CMakeLists.txt 所在的路径, CMAKE_CURRENT_SOURCE_DIR ##如果是 in-source 编译,它跟 CMAKE_CURRENT_SOURCE_DIR 一致,如果是 out-of-source 编译,他指的是 target 编译目录。 ##使用我们上面提到的 ADD_SUBDIRECTORY(src bin)可以更改这个变量的值 CMAKE_CURRENT_BINARY_DIR ##输出调用这个变量的 CMakeLists.txt 的完整路径 CMAKE_CURRENT_LIST_FILE ## ","permalink":"https://Lsiyu7.github.io/en/posts/tech/cmake/","summary":"基础语法 尽量保证每一个文件夹有个CMakeLists.txt [[CMake Practice.pdf]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38","title":"Cmake"},{"content":"gcc/g++常用编译选项 选项 作用 -c 生成可目标文件，但不进行链接 -o 指定生成文件的文件名 -g 在目标文件中添加调试信息，便于gdb调试或objdump反汇编 -Wall 显示所有的警告信息(建议使用) -Werror 视警告为错误，出现警告即放弃编译 -w 不显示任何警告信息(不建议使用) -v 显示编译步骤 -On (n=0,1,2,3) 设置编译器优化等级，O0为不优化，O3为最高等级优化，O1为默认优化等级 -L 指定库文件的搜索目录 -l (小写的L)链接某一库 -I (大写的i)指定头文件路径 -D 定义宏，例如-DAAA=1,-DBBBB -U 取消宏定义，例如-UAAA gdb常用调试命命令 我们的可执行文件要能够被gdb调试，必须在编译时加上调试信息，也即是加上-g选项.\n1\n$ gcc -g example.c -o example\n如上我们生成了一个带有调试信息的可执行文件example,要调试example可以执行下列命令:\n1\n$ gdb example\n这样我们就进入了gdb的调试命令行，如下所示:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nGNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git\nCopyright (C) 2018 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n\u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;.\nFind the GDB manual and other documentation resources online at:\n\u0026lt;http://www.gnu.org/software/gdb/documentation/\u0026gt;.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from example...done.\n(gdb)\n如上可以看到命令行提示符为(gdb),接着我们就可以在这个gdb的命令行提示符上面输入各种gdb的调试命令了(补充:这里也可以在shell中输入gdb,然后回车，这样直接进入到gdb的调试命令行，之后可以通过file example命令来载入待调试的可执行程序)。\n下面我们就以如下的程序为例，详细的看下，在gdb的调试命令行中我们都有那些命令可用:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n#include \u0026lt;stdio.h\u0026gt;\nlong func(int a){\nlong sum = 0;\nfor(int j=1;j\u0026lt;=a;j++){\nsum += j;\n}\nreturn sum;\n}\nint main(void){\nint a =100;\nlong sum = func(a);\nprintf(\"%ld\",sum);\nreturn 0;\n}\n查看源码 载入待调试的可执行文件之后，在gdb的命令行中输入list或者其简写l可以查看到程序的源码以及行号，如下:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n(gdb) l\n1#include \u0026lt;stdio.h\u0026gt;\n2\n3long func(int a){\n4 long sum = 0;\n5 for(int j=1;j\u0026lt;=a;j++){\n6 sum += j;\n7 }\n8 return sum;\n9}\n10\n(gdb) 11int main(void){\n12 int a =100;\n13 long sum = func(a);\n14 printf(\"%ld\",sum);\n15 return 0;\n16}\n(gdb) Line number 17 out of range; example.c has 16 lines.\n(gdb)\n如上输入l之后，默认会显示10行源代码，按回车之后会显示接下来的10行,直到文件的末尾。\n添加断点 在gdb下添加断点使用命令break或简写 b，有下面几个常见用法（这里统一用 b:\n1\n2\n3\n4\nb 函数名\nb 行号\nb 文件名:行号\nb 行号 if条件\n比如我们在 main函数和func函数上各添加一个断点：\n1\n2\n3\n4\n(gdb) b main\nBreakpoint 1 at 0x685: file example.c, line 12.\n(gdb) break func\nBreakpoint 2 at 0x651: file example.c, line 4.\n如上我们成功加上了两个断点，在正确加上断点之后，会对应有一行输出，告诉我们断点的内存地址，断点对应的源文件名和行号。\n查看断点 在加上断点之后，我们可以通过info break命令查看断点的信息:\n1\n2\n3\n4\n(gdb) info break\nNum Type Disp Enb Address What\n1 breakpoint keep y 0x0000000000000685 in main at example.c:12\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n禁用和解禁断点 通过disable \u0026lt;break number\u0026gt;来禁用指定Num的断点，如下我们禁用1号断点:\n1\n2\n3\n4\n5\n(gdb) disable 1\n(gdb) info break\nNum Type Disp Enb Address What\n1 breakpoint keep n 0x0000000000000685 in main at example.c:12\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n如上，disable 1之后，断点1的Enb列由之前的y变成了n，说明断点1已被禁用。\n通过eable \u0026lt;break number\u0026gt;可以来解禁断点，如下我们对刚才禁用的断点1解禁:\n1\n2\n3\n4\n5\n(gdb) enable 1\n(gdb) info break\nNum Type Disp Enb Address What\n1 breakpoint keep y 0x0000000000000685 in main at example.c:12\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n如上，断点1的Enb列又变成y了，它被成功解禁。\n删除断点 我们可以用delete \u0026lt;break number\u0026gt;命令来删除掉一个断点，如下我们删除断点1:\n1\n2\n3\n4\n(gdb) delete 1\n(gdb) info break\nNum Type Disp Enb Address What\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n如上，断点1被成功删除。\n启动程序 我们可以使用run命令或者简写r来启动程序的执行:\n1\n2\n3\n4\n5\n(gdb) r\nStarting program: /home/andrew/example Breakpoint 2, func (a=100) at example.c:4\n4 long sum = 0;\n如上，程序执行到断点2的时候就停止执行了。\n查看变量的值 p \u0026lt;variable name\u0026gt;/print \u0026lt;variable name\u0026gt;可以查看某一个变量的当前值:\n1\n2\n(gdb) p sum\n$1 = 0\n如上，当前sum的值为0\n单步执行 next命令或者n可以单步执行，如下:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) p sum\n$2 = 0\n(gdb) n\n6 sum += j;\n(gdb) p sum\n$3 = 0\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) p sum\n$4 = 1\n(gdb) n\n6 sum += j;\n(gdb) p sum\n$5 = 1\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) p sum\n$6 = 3\n跳入跳出函数 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n(gdb) break 13\nBreakpoint 1 at 0x693: file example.c, line 13.\n(gdb) r\nStarting program: /home/andrew/example Breakpoint 1, main () at example.c:13\n13 long sum = func(a);\n(gdb) s\nfunc (a=100) at example.c:4\n4 long sum = 0;\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) n\n6 sum += j;\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) n\n6 sum += j;\n(gdb) finish\nRun till exit from #0 func (a=100) at example.c:6\n0x000055555555469d in main () at example.c:13\n13 long sum = func(a);\nValue returned is $1 = 5050\n(gdb) n\n14 printf(\"%ld\",sum);\n(gdb)\n如上，我在func()函数调用行加上了断点，然后r开始执行程序，之后程序在断点处停住，此时我执行step命令或其简写s来跳入func()函数内部调试，在内部依然像执行外部调试一样，如果要从函数跳出则执行finished，这时会导致函数执行完毕，并且打印出一些函数的返回信息，并且程序停在函数后的第一条语句处。\n监控变量 使用watch \u0026lt;varible name\u0026gt;命令可以实现监控变量，使用info watch命令可以查看监控的变量。同时break所拥有的enable,disable,delete等动词对于watch依然使用，且用法大同小异。这里就不再赘述。\n显示变量的值 使用display \u0026lt;varible name\u0026gt;命令可以在每一步执行之后打印变量的当前值,如下:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n(gdb) start Temporary breakpoint 1 at 0x685: file example.c, line 12.\nStarting program: /home/andrew/example Temporary breakpoint 1, main () at example.c:12\n12 int a =100, b =50;\n(gdb) display sum\n1: sum = 140737488346112\n(gdb) n\n13 long sum = func(a);\n1: sum = 140737488346112\n(gdb) 14 printf(\"%ld\",sum);\n1: sum = 5050\n(gdb) 16 long sum2 = func(b);\n1: sum = 5050\n(gdb) 17 printf(\"%ld\",sum2);\n1: sum = 5050\n(gdb) 18 return 0;\n1: sum = 5050\n(gdb)\n进入shell shell命令可以让我们从gdb命令行环境进入到shell的命令行环境，当我们在shell命令行环境中输入exit退出后，我们就又回到了之前的gdb命令行环境了。\n可视化调试 在gdb命令行环境中输入wi命令，可以让我们进入可视化调试环境，这个环境可以看到源代码，所使用的调试命令与上面讲到的一致。\n","permalink":"https://Lsiyu7.github.io/en/posts/tech/gdb/","summary":"gcc/g++常用编译选项 选项 作用 -c 生成可目标文件，但不进行链接 -o 指定生成文件的文件名 -g 在目标文件中添加调试信息，便于gdb调试或objdu","title":"Gdb"}]