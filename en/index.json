[{"content":"gcc/g++常用编译选项 选项 作用 -c 生成可目标文件，但不进行链接 -o 指定生成文件的文件名 -g 在目标文件中添加调试信息，便于gdb调试或objdump反汇编 -Wall 显示所有的警告信息(建议使用) -Werror 视警告为错误，出现警告即放弃编译 -w 不显示任何警告信息(不建议使用) -v 显示编译步骤 -On (n=0,1,2,3) 设置编译器优化等级，O0为不优化，O3为最高等级优化，O1为默认优化等级 -L 指定库文件的搜索目录 -l (小写的L)链接某一库 -I (大写的i)指定头文件路径 -D 定义宏，例如-DAAA=1,-DBBBB -U 取消宏定义，例如-UAAA gdb常用调试命命令 我们的可执行文件要能够被gdb调试，必须在编译时加上调试信息，也即是加上-g选项.\n1\n$ gcc -g example.c -o example\n如上我们生成了一个带有调试信息的可执行文件example,要调试example可以执行下列命令:\n1\n$ gdb example\n这样我们就进入了gdb的调试命令行，如下所示:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nGNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git\nCopyright (C) 2018 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n\u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;.\nFind the GDB manual and other documentation resources online at:\n\u0026lt;http://www.gnu.org/software/gdb/documentation/\u0026gt;.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from example...done.\n(gdb)\n如上可以看到命令行提示符为(gdb),接着我们就可以在这个gdb的命令行提示符上面输入各种gdb的调试命令了(补充:这里也可以在shell中输入gdb,然后回车，这样直接进入到gdb的调试命令行，之后可以通过file example命令来载入待调试的可执行程序)。\n下面我们就以如下的程序为例，详细的看下，在gdb的调试命令行中我们都有那些命令可用:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n#include \u0026lt;stdio.h\u0026gt;\nlong func(int a){\nlong sum = 0;\nfor(int j=1;j\u0026lt;=a;j++){\nsum += j;\n}\nreturn sum;\n}\nint main(void){\nint a =100;\nlong sum = func(a);\nprintf(\"%ld\",sum);\nreturn 0;\n}\n查看源码 载入待调试的可执行文件之后，在gdb的命令行中输入list或者其简写l可以查看到程序的源码以及行号，如下:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n(gdb) l\n1#include \u0026lt;stdio.h\u0026gt;\n2\n3long func(int a){\n4 long sum = 0;\n5 for(int j=1;j\u0026lt;=a;j++){\n6 sum += j;\n7 }\n8 return sum;\n9}\n10\n(gdb) 11int main(void){\n12 int a =100;\n13 long sum = func(a);\n14 printf(\"%ld\",sum);\n15 return 0;\n16}\n(gdb) Line number 17 out of range; example.c has 16 lines.\n(gdb)\n如上输入l之后，默认会显示10行源代码，按回车之后会显示接下来的10行,直到文件的末尾。\n添加断点 在gdb下添加断点使用命令break或简写 b，有下面几个常见用法（这里统一用 b:\n1\n2\n3\n4\nb 函数名\nb 行号\nb 文件名:行号\nb 行号 if条件\n比如我们在 main函数和func函数上各添加一个断点：\n1\n2\n3\n4\n(gdb) b main\nBreakpoint 1 at 0x685: file example.c, line 12.\n(gdb) break func\nBreakpoint 2 at 0x651: file example.c, line 4.\n如上我们成功加上了两个断点，在正确加上断点之后，会对应有一行输出，告诉我们断点的内存地址，断点对应的源文件名和行号。\n查看断点 在加上断点之后，我们可以通过info break命令查看断点的信息:\n1\n2\n3\n4\n(gdb) info break\nNum Type Disp Enb Address What\n1 breakpoint keep y 0x0000000000000685 in main at example.c:12\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n禁用和解禁断点 通过disable \u0026lt;break number\u0026gt;来禁用指定Num的断点，如下我们禁用1号断点:\n1\n2\n3\n4\n5\n(gdb) disable 1\n(gdb) info break\nNum Type Disp Enb Address What\n1 breakpoint keep n 0x0000000000000685 in main at example.c:12\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n如上，disable 1之后，断点1的Enb列由之前的y变成了n，说明断点1已被禁用。\n通过eable \u0026lt;break number\u0026gt;可以来解禁断点，如下我们对刚才禁用的断点1解禁:\n1\n2\n3\n4\n5\n(gdb) enable 1\n(gdb) info break\nNum Type Disp Enb Address What\n1 breakpoint keep y 0x0000000000000685 in main at example.c:12\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n如上，断点1的Enb列又变成y了，它被成功解禁。\n删除断点 我们可以用delete \u0026lt;break number\u0026gt;命令来删除掉一个断点，如下我们删除断点1:\n1\n2\n3\n4\n(gdb) delete 1\n(gdb) info break\nNum Type Disp Enb Address What\n2 breakpoint keep y 0x0000000000000651 in func at example.c:4\n如上，断点1被成功删除。\n启动程序 我们可以使用run命令或者简写r来启动程序的执行:\n1\n2\n3\n4\n5\n(gdb) r\nStarting program: /home/andrew/example Breakpoint 2, func (a=100) at example.c:4\n4 long sum = 0;\n如上，程序执行到断点2的时候就停止执行了。\n查看变量的值 p \u0026lt;variable name\u0026gt;/print \u0026lt;variable name\u0026gt;可以查看某一个变量的当前值:\n1\n2\n(gdb) p sum\n$1 = 0\n如上，当前sum的值为0\n单步执行 next命令或者n可以单步执行，如下:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) p sum\n$2 = 0\n(gdb) n\n6 sum += j;\n(gdb) p sum\n$3 = 0\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) p sum\n$4 = 1\n(gdb) n\n6 sum += j;\n(gdb) p sum\n$5 = 1\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) p sum\n$6 = 3\n跳入跳出函数 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n(gdb) break 13\nBreakpoint 1 at 0x693: file example.c, line 13.\n(gdb) r\nStarting program: /home/andrew/example Breakpoint 1, main () at example.c:13\n13 long sum = func(a);\n(gdb) s\nfunc (a=100) at example.c:4\n4 long sum = 0;\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) n\n6 sum += j;\n(gdb) n\n5 for(int j=1;j\u0026lt;=a;j++){\n(gdb) n\n6 sum += j;\n(gdb) finish\nRun till exit from #0 func (a=100) at example.c:6\n0x000055555555469d in main () at example.c:13\n13 long sum = func(a);\nValue returned is $1 = 5050\n(gdb) n\n14 printf(\"%ld\",sum);\n(gdb)\n如上，我在func()函数调用行加上了断点，然后r开始执行程序，之后程序在断点处停住，此时我执行step命令或其简写s来跳入func()函数内部调试，在内部依然像执行外部调试一样，如果要从函数跳出则执行finished，这时会导致函数执行完毕，并且打印出一些函数的返回信息，并且程序停在函数后的第一条语句处。\n监控变量 使用watch \u0026lt;varible name\u0026gt;命令可以实现监控变量，使用info watch命令可以查看监控的变量。同时break所拥有的enable,disable,delete等动词对于watch依然使用，且用法大同小异。这里就不再赘述。\n显示变量的值 使用display \u0026lt;varible name\u0026gt;命令可以在每一步执行之后打印变量的当前值,如下:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n(gdb) start Temporary breakpoint 1 at 0x685: file example.c, line 12.\nStarting program: /home/andrew/example Temporary breakpoint 1, main () at example.c:12\n12 int a =100, b =50;\n(gdb) display sum\n1: sum = 140737488346112\n(gdb) n\n13 long sum = func(a);\n1: sum = 140737488346112\n(gdb) 14 printf(\"%ld\",sum);\n1: sum = 5050\n(gdb) 16 long sum2 = func(b);\n1: sum = 5050\n(gdb) 17 printf(\"%ld\",sum2);\n1: sum = 5050\n(gdb) 18 return 0;\n1: sum = 5050\n(gdb)\n进入shell shell命令可以让我们从gdb命令行环境进入到shell的命令行环境，当我们在shell命令行环境中输入exit退出后，我们就又回到了之前的gdb命令行环境了。\n可视化调试 在gdb命令行环境中输入wi命令，可以让我们进入可视化调试环境，这个环境可以看到源代码，所使用的调试命令与上面讲到的一致。\n","permalink":"https://Lsiyu7.github.io/en/posts/tech/gdb/","summary":"gcc/g++常用编译选项 选项 作用 -c 生成可目标文件，但不进行链接 -o 指定生成文件的文件名 -g 在目标文件中添加调试信息，便于gdb调试或objdu","title":"Gdb"}]